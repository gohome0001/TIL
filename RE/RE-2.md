## 64bit 환경에서의 스택 처리

call을 해서, 흔히 아는 `함수 프롤로그`의 오버헤드를 줄이기 위해서 꽤나 달라진 거 같다.

일단, 다음의 코드를 보자.
```asm
push ebp
mov ebp, esp
```
이게 흔히 알던 함수 프롤로그인데,

32bit 환경에서는 저렇게 하던걸 64bit에서는 다르다!.(물론 옵션주면 같게할수도)

1. 스택 지역/매개변수는 esp를 통해 접근한다.

- ebp를 범용 레지스터로 사용할 수 있다!

그렇다면, 함수 호출시 calling convention은..?

2. 64bit에서는 그 stdcall, fastcall, cdecl같이 구별하지 않고, 하나로 통일되었다 한다.

- 함수 매개변수 넘길때는 4번쨰까지는 register에, 그 다음부터는 스택 메모리에 넣는데,

- 이게 push 를 사용하지 않고 mov로 [esp+disp] 이렇게 접근한고 한다.

- 이러면 함수 프롤/에필로그에서 스택 포인터는 동일하게 유지된다.

3. 함수의 로컬 공간 확보/해제를 위해선 함수 시작과 마지막에 add/sub esp, allocation-size 해주면 된다.

아까 레지스터에 넣었던 매개변수는 함수 안에 들어가서는 `Parameter Homing` 사용해서 다시 스택에 저장해준다 한다.

이게 5, 6..번쨰 매개변수 넘길때 보면 1~4 매개변수 넣을 주소값에 이미 더해져 들어간다 한다.

이 homing 기법은 caller `비단말` 함수일떄만 가능한데, 왜냐면 단말 callee 가 없으니까..

즉, 부모함수가 자식함수를 위해 스택공간을 미리 확보해준다는 것이다(매개변수를 위해서만. 자식의 자식함수는 고려안함)

push 쓸 떄는, 64bit는 휘발성, 비휘발성 레지스터를 명시적으로 구별한다 했었는..데

이떄 비휘발성 레지스터를 call 하자마자 push 한다.

최종 함수 프레임은 32bit와 크게 다를거는 없다. param, ret, local stack, param, ret, local stack....이렇게 쌓여서...

## 최적화

**inline 함수**

함수를 call 한다는 거 자체가 오버해드라 생각했는지(...) 

함수를 call하는게 아니라 코드 자체에 삽입해서 실행하는 처리.

물론 원치않으면 안하게 할 수도 있음.
> declspec(noinline)


**최종 호출 제거.**

```c
return func(a, b...)
```
이런식으로 또다른 함수 return value가 함수의 return value 일때, call 한 후에 그 return 값을 return 하는게 아니라

jmp로 가서 거기서 return하게 하는 방식이다.

-------

다음 차례 : instruction format.

